# -*- coding: utf-8 -*-
"""E.Coli_script.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1S2SqNWxa3kxGmJbJbOYs5L8XeVyn7D--
"""

import re
import pandas as pd
from Bio import SeqIO

#pip install biopython --upgrade

# read in BLAST alignment output
df = pd.read_csv('BLAST_results.out', sep='\t', header = None)

# take the max identity % (column "2") for each alignment
condensed_df = df.drop_duplicates([0])
condensed_df.reset_index(drop=True, inplace=True)
condensed_df.head()

# read in fasta file
record = SeqIO.read("all.fna", "fasta")

# store ID for output file
file_name = record.id

def get_locations(file, key_word):

  lines = open(file).readlines()

  prot_list = []
  for line in lines:
    if line[0] == '>':
        prot_list.append(line[1:])
  
  b = [idx for i in key_word.split() for idx, j in enumerate(prot_list) if i in j]

  result = re.search('(?<=\#\ )(.*?)(?=\ \#)', prot_list[b[0]])
  start = int(result.group(1))
  result = re.search('(?:.*?\#\ ){2}(.*?)(?=\ \#)', prot_list[b[0]])
  end = int(result.group(1))

  return start, end

def range_subset(range1, range2):
    """Whether range1 is a subset of range2. 
    https://stackoverflow.com/questions/32480423/how-to-check-if-a-range-is-a-part-of-another-range-in-python-3-x
    """
    if not range1:
        return True  # empty range is subset of anything
    if not range2:
        return False  # non-empty range can't be subset of empty range
    if len(range1) > 1 and range1.step % range2.step:
        return False  # must have a single value or integer multiple step
    return range1.start in range2 and range1[-1] in range2

# lists to hold PICI headers and sequences for fasta output
name_list = []
seq_list = []



for i in range(len(condensed_df)):
  if condensed_df.iloc[i,1].startswith('int'): # find integrases in df
    if condensed_df.iloc[i,2] >= 0.9: # check it integrase identity is above 90%
      print('Integrase found with identity >= 90%:')
      print(condensed_df.iloc[i,0])
      
      # take the protein number of the int ("0" column)
      int_prot_num = int((condensed_df.iloc[i,0]).split('_')[-1])
      
      #set lower and upper bounds for alpA to be found (to the left and right of int)
      alpA_low_lim_forward = int_prot_num + 1
      alpA_high_lim_forward = int_prot_num + 4
      alpA_low_lim_backward = int_prot_num - 1
      alpA_high_lim_backward = int_prot_num - 4
      
      # search for co-localized alpA
      for k in range(i-4,i+4):
        # if the index is negative set it to 0
        if k < 0:
          k = 0
        #breaks loop if the index exceeds the dataframe length
        if k >= condensed_df.shape[0]:
          break
        # otherwise get the gene number for alpA  
        elif condensed_df.iloc[k,1].startswith('alpA'):
          alpA_prot_num = int((condensed_df.iloc[k,0]).split('_')[-1])
          # check to see if it is within 1-4 genes away from the integrase  
          if alpA_prot_num in range(alpA_low_lim_forward, alpA_high_lim_forward) or range(alpA_low_lim_backward, alpA_high_lim_backward):

            # Get protein locations in host
            # get the location of alpA and see if pri-rep is within 25 kb to left or right (50kb total)
            int_location_start, int_location_end = get_locations("all.pdg.faa", condensed_df.iloc[i,0])
            alpA_location_start, alpA_location_end = get_locations("all.pdg.faa", condensed_df.iloc[k,0])
            print('\nInt start:', int_location_start)
            print('Int end:',int_location_end)
            print('alpA start:',alpA_location_start)
            print('alpA end:',alpA_location_end)

            # set range for pri-rep to be found 
            pici_low_limit = alpA_location_start - 25000
            pici_high_limit = alpA_location_end + 25000
  

            # fix lower limit index to 0 if it is negative
            if pici_low_limit < 0:
              pici_low_limit = 0


            # fix upper limit index to the length of the sequence if it is over
            if pici_high_limit >= len(record.seq):
              pici_high_limit = len(record.seq)

            range_to_be_discovered = range(pici_low_limit, pici_high_limit)

            # check for pri-rep and if it is in the 50kb range
            for l in range(len(condensed_df)):
              if condensed_df.iloc[l,1].startswith('pri-rep'): # find prirep in df
                prirep_location_start, prirep_location_end = get_locations("all.pdg.faa", condensed_df.iloc[l,0])
                prirep_range = range(prirep_location_start,prirep_location_end)
                
                if range_subset(prirep_range, range_to_be_discovered) == True:
                  print('Pri-rep start:', prirep_location_start)
                  print('Pri-rep end:', prirep_location_end)
                  print('PICI start:', pici_low_limit)
                  print('PICI end:', pici_high_limit)
                  print('\nPICI sequence:')
                  print(record.seq[pici_low_limit:pici_high_limit])
                  print('\nPICI length:', len(record.seq[pici_low_limit:pici_high_limit]))
                  print('\n')

                  # add PICI to list
                  name_list.append(record.id)
                  seq_list.append(record.seq[pici_low_limit:pici_high_limit])





                  
                  


      
  else:
    print('No hit')


# write PICI sequence to file
PICI_file = open(file_name + "_PICI", "w")

for m in range(len(seq_list)):
  PICI_file.write(">" + str(name_list[m]) + "_PICI_" + str(m) + "\n" + str(seq_list[m]) + "\n")

PICI_file.close()